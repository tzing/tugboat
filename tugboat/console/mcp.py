from __future__ import annotations

import logging
import textwrap
import typing
from typing import Annotated, Any, Literal

from mcp.server.fastmcp import FastMCP
from mcp.types import ToolAnnotations
from pydantic import BaseModel, Field

import tugboat.engine

if typing.TYPE_CHECKING:
    from pydantic.fields import FieldInfo

logger = logging.getLogger(__name__)
server = FastMCP("tugboat")


def _Docstring(description: str) -> FieldInfo:
    """Shortcut for creating a description-only Field annotation."""
    description = textwrap.dedent(description).strip()
    return Field(description=description)


class Result(BaseModel):
    """A report generated by the analyzer."""

    count: Annotated[
        int,
        _Docstring("The number of issues found in the manifest."),
    ]

    issues: Annotated[
        list[Issue],
        _Docstring("A list of issues found in the manifest."),
    ]


class Issue(BaseModel):
    """An issue reported by the analyzer."""

    line: Annotated[
        int,
        _Docstring(
            "Line number of the issue occurrence in the source file. The line number is cumulative across all documents in the YAML stream."
        ),
    ]

    column: Annotated[
        int,
        _Docstring("Column number of the issue occurrence in the source file."),
    ]

    type: Annotated[
        Literal["error", "failure", "warning"],
        _Docstring(
            """
            The type of the issue.
            * ``error`` indicates a critical issue that prevents the analyzer from running.
            * ``failure`` indicates an issue that the analyzer has detected.
            * ``warning`` indicates a potential issue that the analyzer has detected. This is not a critical issue, but it may require attention.
            """
        ),
    ]

    code: Annotated[
        str,
        _Docstring("A unique identifier representing the violated rule."),
    ]

    manifest: Annotated[
        str | None,
        _Docstring("The manifest name where the issue occurred."),
    ]

    loc: Annotated[
        tuple[str | int, ...],
        _Docstring(
            """
            A list of keys indicating the location of the issue in the manifest.
            For example, a issue found in the `spec.containers[0].name` field would have a location of `["spec", "containers", 0, "name"]`.
            """
        ),
    ]

    summary: Annotated[
        str,
        _Docstring("A short summary of the issue."),
    ]

    msg: Annotated[
        str,
        _Docstring("A human-readable message describing the issue."),
    ]

    input: Annotated[
        str | int | bool | float | Any | None,
        _Docstring("The input that caused the issue."),
    ]

    fix: Annotated[
        str | None,
        _Docstring(
            """
            A possible fix to the issue.
            This output is based on the analyzer's best guess and may not be correct.
            """
        ),
    ]


@server.tool(
    annotations=ToolAnnotations(
        title="Analyze Manifest",
        readOnlyHint=True,
        destructiveHint=False,
        openWorldHint=False,
    )
)
def analyze_stream(
    manifest_path: Annotated[
        str,
        _Docstring(
            "Path to the manifest file. The file must be a valid Kubernetes manifest file in YAML format. Any templated manifests (e.g., Helm) should be pre-processed before submission."
        ),
    ],
) -> Result:
    """
    A linter to analyze a Argo Workflows manifest file for potential issues.

    ## Example

    Given the input manifest path `/path/to/manifest.yaml`, which contains:

    ```yaml
    apiVersion: argoproj.io/v1alpha1
    kind: Workflow
    metadata:
      generateName: demo-
    spec:
      templates:
        - name: whalesay
          inputs:
            parameters:
              - name: message
                value: Hello Argo!
          container:
            image: docker/whalesay:latest
            command: [cowsay]
            args:
              - "{{ inputs.parameter.message }}"
    ```

    This tool will analyze the manifest and return a JSON object with the following structure:

    ```json
    {"count":2,"issues":[[{"code":"M101","column":5,"fix":null,"input":null,"line":6,"loc":["spec","entrypoint"],"manifest":"demo-","msg":"Field 'entrypoint' is required in the 'spec' section but missing.","summary":"Missing required field 'entrypoint'","type":"failure"},{"code":"VAR002","column":17,"fix":"{{ inputs.parameters.message }}","input":"{{ inputs.parameter.message }}","line":17,"loc":["spec","templates",0,"container","args",0],"manifest":"demo-","msg":"The parameter reference 'inputs.parameter.message' used in template 'whalesay' is invalid.","summary":"Invalid reference","type":"failure"}]]}
    ```
    """
    logger.debug("Linting manifest %s", manifest_path)

    with open(manifest_path) as fd:
        manifest_content = fd.read()

    diagnoses = tugboat.engine.analyze_yaml_stream(manifest_content, manifest_path)

    return Result.model_validate(
        {
            "count": len(diagnoses),
            "issues": diagnoses,
        }
    )
